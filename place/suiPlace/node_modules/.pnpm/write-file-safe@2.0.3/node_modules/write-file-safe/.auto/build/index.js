import fs, { promises } from "fs";
import { tmpdir } from "os";
import { dirname, join } from "path";
import { writeDir, writeDirSync } from "write-dir-safe";
import { removeFile } from "remove-file-safe";
import { addTerminatingNewline } from "terminating-newline";
function handleNewline(content, appendNewline) {
    if (appendNewline !== null && appendNewline !== void 0 ? appendNewline : true) {
        return addTerminatingNewline(content);
    } else {
        return content;
    }
}
let counter = 0;
async function openTemp() {
    const path = join(tmpdir(), `.${process.pid}.${counter}`);
    counter += 1;
    return promises.open(path, "wx").then((fd)=>{
        return {
            fd,
            path,
            cleanup: ()=>{
                fd.close().then(()=>{
                    removeFile(path);
                });
            }
        };
    }).catch((error)=>{
        if (error && error.code === "EEXIST") {
            return openTemp();
        } else {
            return undefined;
        }
    });
}
export async function writeFile(path, content = "", options = {}) {
    let mode;
    const stat = await promises.stat(path).catch(()=>undefined);
    if (stat) {
        if (options.overwrite === false) {
            return true;
        }
        mode = stat.mode;
    }
    return openTemp().then((temp)=>{
        if (temp) {
            return promises.writeFile(temp.fd, handleNewline(content, options.appendNewline)).then(async ()=>{
                // Set the mode of the temp file to match the original file, if one was found
                if (mode !== undefined) {
                    await promises.chmod(temp.path, mode);
                }
                // Make sure a directory exists for the target file
                const directory = dirname(path);
                var _options_recursive;
                if ((_options_recursive = options.recursive) !== null && _options_recursive !== void 0 ? _options_recursive : true) {
                    await writeDir(directory);
                }
                // Rename the temp file to the target file
                return promises.rename(temp.path, path).then(()=>{
                    return true;
                }).catch(async (error)=>{
                    if (error.code === "EXDEV") {
                        // temp file and target file are on different volumes, so we need to copy
                        await promises.copyFile(temp.path, path);
                        await promises.unlink(temp.path);
                        return true;
                    } else {
                        return false; // Unable to rename temp file
                    }
                });
            }).catch(()=>{
                return false; // Unable to write to temp file
            }).finally(()=>{
                temp.cleanup();
            });
        } else {
            return false; // Unable to resolve temp directory
        }
    });
}
export function writeFileSync(path, content = "", options = {}) {
    let mode;
    try {
        // eslint-disable-next-line no-sync
        const stat = fs.statSync(path);
        if (options.overwrite === false) {
            return true;
        }
        mode = stat.mode;
    } catch (e) {
    // File does not exist
    }
    const directory = dirname(path);
    var _options_recursive;
    if ((_options_recursive = options.recursive) !== null && _options_recursive !== void 0 ? _options_recursive : true) {
        writeDirSync(directory);
    }
    try {
        // eslint-disable-next-line no-sync
        fs.writeFileSync(path, handleNewline(content, options.appendNewline));
        if (mode !== undefined) {
            // eslint-disable-next-line no-sync
            fs.chmodSync(path, mode);
        }
        return true;
    } catch (e) {
        return false;
    }
}
